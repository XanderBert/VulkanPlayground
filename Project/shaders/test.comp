#version 450

#define PI              3.1415f
#define TWO_PI          (2.0f * PI)
#define GOLDEN_ANGLE    2.4f
#define SAMPLES_COUNT   16
#define CONTRAST        2.0f

layout(push_constant) uniform constants {
    mat4 viewMatrix;
} push;

layout(set = 0, binding = 0) uniform UniformBufferObject {
    mat4 inverseProjection;
} ubo;

layout(set = 1, binding = 0) uniform UniformBufferCompute {
    vec4 nearPlaneSizeNormalized;
    vec4 aspect;
    vec4 radiusWorld;
    vec4 maxRadiusScreen;
} computeUbo;

layout(set = 1, binding = 1) uniform sampler2D depthResource;
layout(set = 1, binding = 2) uniform sampler2D normalResource;
layout(set = 1, binding = 3, rgba8) uniform image2D ssaoOutput;
layout(local_size_x = 32, local_size_y = 32, local_size_z = 1) in;

vec3 Position_View(vec2 texCoord)
{
    vec3 position = vec3(texCoord, -1.0f);
    position.xy -= 0.5f;
    position.y *= -1.0f;
    position.xy *= computeUbo.nearPlaneSizeNormalized.xy;
    float depth = texture(depthResource, texCoord).x;
    position *= -depth;
    return position;
}

float InterleavedGradientNoise(vec2 position_screen) {
    vec3 magic = vec3(0.06711056f, 4.0f * 0.00583715f, 52.9829189f);
    return fract(magic.z * fract(dot(position_screen, magic.xy)));
}

vec2 VogelDiskOffset(int sampleIndex, float phi) {
    float r = sqrt(float(sampleIndex) + 0.5f) / sqrt(float(SAMPLES_COUNT));
    float theta = sampleIndex * GOLDEN_ANGLE + phi;
    return r * vec2(cos(theta), sin(theta));
}

void main()
{
    ivec2 texCoord = ivec2(gl_GlobalInvocationID.xy);
    vec2 normalizedTexCoord = vec2(texCoord) / vec2(imageSize(ssaoOutput));

    vec3 position = Position_View(normalizedTexCoord);
    vec3 normal = texture(normalResource, normalizedTexCoord).xyz;
    //normal = 2.0f * normal - 1.0f;
    normal = mat3(push.viewMatrix) * normal;

    float noise = InterleavedGradientNoise(texCoord.xy);

    vec2 radiusScreen = vec2(0.1 / position.z);

    radiusScreen = min(radiusScreen, vec2(0.003));
    radiusScreen.y *= computeUbo.aspect.x;


    float ao = 0.0f;

    for (int i = 0; i < SAMPLES_COUNT; i++) {
        vec2 sampleOffset = VogelDiskOffset(i, TWO_PI * noise);
        vec2 sampleTexCoord = normalizedTexCoord + (radiusScreen * sampleOffset);

        vec3 samplePosition = Position_View(sampleTexCoord);
        vec3 v = samplePosition - position;

        ao += max(0.0f, dot(v, normal) + 0.002f * position.z) / (dot(v, v) + 0.001f);
    }

    ao = clamp(ao / float(SAMPLES_COUNT), 0.0f, 1.0f);
    //ao = 1 - ao;

    ao = pow(ao, CONTRAST);

    imageStore(ssaoOutput, texCoord, vec4(ao));
}

